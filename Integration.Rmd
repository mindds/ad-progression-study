---
title: "Integration"
description: |
  The code integrates single cell RNA sequencing data from 5 brain regios of 32 donors. The following code should be run in a GPU cluster.
date: "`r Sys.Date()`"
output: 
  distill::distill_article
  toc: true
---

Run on GPU cluster 

Integrate data: There are 5 brain regions and 32 donors (5x32 samples)
```{r}
#specify paths
data_path <- "data/"
scripts_path <- "scripts/"
annie_path <- "scripts/annie/"
plot_dir <- paste0(annie_path, "results/plots/manuscript/")

# Define paths for data input/output
rdata_path_in <- paste0(data_path, "Rdata/")
rdata_path_out <- paste0(data_path, "Rdata/annie/")
results_path <- paste0(annie_path, "results/")
brain_regions <- c("BA20", "BA46", "EC", "V1", "V2")

# Use 4 cores
ncore <- 4

# Load packages
library(Seurat)
library(data.table)
library(tidyverse)
library(rstatix)
library(ggpubr)
library(cowplot)
library(RColorBrewer)
library(doParallel)
library(foreach)

select <- dplyr::select
theme_set(theme_cowplot())


# function to integrate the data


process_and_integrate_raw_data <- function(seurat.obj, # Input seurat object
                                           brain_region, # Brain region, e.g. BA46
                                           rdata_file_out, # path to output .Rdata file
                                           regress_vars=c("nCount_RNA", "percent.mito"), # variables to regress out
                                           n_HVGs=2000 # Number of highly-variable genes
) {

  # Print the number of genes and cells in the dataset
  cat(sprintf("Original %s data have %s genes.\n", brain_region, nrow(seurat.obj@assays$RNA@data)))
  cat(sprintf("Original %s data have %s cells.\n", brain_region, ncol(seurat.obj@assays$RNA@data)))

  # Split seurat data by donor ID (ADRC #)
  seurat_split <- SplitObject(seurat.obj, split.by="Donor.ID")

  # Free up memory in workspace
  rm(seurat.obj)

  # normalize and identify variable features for each dataset independently
  cat("\nNormalizing data\n")
  seurat_split <- lapply(X = seurat_split, FUN = function(x) {
    x <- NormalizeData(x, verbose=F) # lognormalize
    x <- FindVariableFeatures(x, selection.method = "vst", nfeatures = n_HVGs,
                              verbose=F) # find top 2,000 variable genes
  })

  # Save point in case r crashes
  save(seurat_split, file=rdata_file_out)

  # select features that are repeatedly variable across datasets for integration run PCA on each
  # dataset using these features
  cat("\nSelecting integration features\n")
  anchor_features <- SelectIntegrationFeatures(object.list = seurat_split, nfeatures = n_HVGs)
  seurat_split <- lapply(X = seurat_split, FUN = function(x) {
    x <- ScaleData(x, features = anchor_features, verbose = F)
    x <- RunPCA(x, features = anchor_features, verbose = F)
  })

  # Save point in case r crashes
  save(seurat_split, anchor_features, file=rdata_file_out)

  # Perform integration using reciprocal PCA (rPCA)
  cat("\nFinding integration anchors\n")
  integration_anchors = FindIntegrationAnchors(object.list = seurat_split,
                                               anchor.features = anchor_features,
                                               reduction = "rpca")

  # Save point in case r crashes
  save(integration_anchors, file=rdata_file_out)

  # this command creates an 'integrated' data assay
  seurat_proc <- IntegrateData(anchorset = integration_anchors)

  # Save point in case r crashes
  save(seurat_proc, file=rdata_file_out)

  # Free up memory in workspace
  rm(seurat_split, integration_anchors)

  # Specify that the next analyses should be on the integrated assay
  DefaultAssay(seurat_proc) <- "integrated"

  # scale integrated data and run regular PCA for dimensionality reduction
  cat("\nScaling integrated data and performing PCA\n")
  seurat_proc <- ScaleData(seurat_proc, verbose = T, vars.to.regress = regress_vars)
  seurat_proc <- RunPCA(seurat_proc, npcs = 50, verbose = F)

  # UMAP nonlinear dimension reduction
  seurat_proc <- RunUMAP(seurat_proc, reduction = "pca", dims = 1:30)

  # Graph-based neighbor detection
  seurat_proc <- FindNeighbors(seurat_proc, reduction = "pca", dims = 1:30)

  # Identify clusters at resolutions 0.1 through 1.0
  seurat_proc <- FindClusters(seurat_proc, resolution = seq(0.1, 1, by=0.1))

  # Assign brain region name to variable and save
  assign(paste0(brain_region, "_rPCA"), seurat_proc)
  save(list=ls(pattern=("_rPCA")), file=rdata_file_out)

  # Clean up workspace
  rm(seurat_proc)

}

# Iterate over our brain regions


for (brain_region in brain_regions) {
  print(sprintf("Now starting %s", brain_region))

  # Define input and output Rdata files
  rdata_in_file <- paste0(rdata_path_in, sprintf("%s_preprocessed.Rdata", brain_region)) # raw data
  rdata_out_file <- paste0(rdata_path_out, sprintf("%s_rPCA_new.Rdata", brain_region)) # integrated data

  if (!file.exists(rdata_out_file)) {
    print(sprintf("Now processing %s", brain_region))

    # Load raw snRNAseq data
    load(rdata_in_file)

    # Run rPCA integration function on data for current brain region
    process_and_integrate_raw_data(seurat.obj=get(brain_region),
                                   brain_region=brain_region,
                                   rdata_file_out=rdata_out_file,
                                   regress_vars=regress_vars,
                                   n_HVGs=2000)
  }
}

```
