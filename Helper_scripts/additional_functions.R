#' convert data.frame to data.table
#' @param data.df data.frame; 
#' @param rowcol string; column names in new data.table which stores the 
#' row names of data.frame
df_to_dt = function(data.df, rowcol = "genes"){
  rnames = rownames(data.df)
  data.dt = data.table::copy(data.df)
  setDT(data.dt)
  data.dt[[rowcol]] = rnames
  return(data.dt)
}


#' normalized counts of given celltype
#' @param seurat.obj seurat objects
counts_n_ctype = function(seurat.obj){
  genes = rownames(seurat.obj@assays$RNA@counts)
  projids.u = unique(seurat.obj@meta.data$Donor.ID)
  ctypes = Idents(seurat.obj)
  expr_l = array(NA, dim = c(length(genes), 
                             length(projids.u),
                             length(unique(ctypes))))
  dimnames(expr_l)[[1]] = genes
  dimnames(expr_l)[[2]] = projids.u
  dimnames(expr_l)[[3]] = sort(as.character(unique(ctypes)))
  for(ctype in sort(unique(ctypes))){
    cat("processing", ctype, "...\n")
    ctype.obj = seurat.obj[, ctypes == ctype]
    DefaultAssay(ctype.obj) = "RNA"
    expr = ind_expr(counts = ctype.obj@assays$RNA@counts,
                    projids = ctype.obj@meta.data$Donor.ID,
                    projids.u = projids.u)
    tmp = diag(1/(colSums(expr) + 0.1^8))
    rownames(tmp) = colnames(tmp) = colnames(expr)
    expr_n = expr %*% tmp
    cat("check gene order: ", all(rownames(expr_n) == genes), "\n")
    cat("check sample order: ", all(colnames(expr_n) == projids.u), "\n")
    # check
    # colSums(expr_n)
    expr_l[,, as.character(ctype)] = expr_n * 10^6
  }
  return(expr_l)
}


#' sum counts by celltypes
#' @param seurat.obj seurat objects
#' must include ctypes column in the metadata
counts_ctype = function(seurat.obj){
  genes = rownames(seurat.obj@assays$RNA@counts)
  projids.u = unique(seurat.obj@meta.data$Donor.ID)
  Idents(seurat.obj) = seurat.obj$ctypes
  ctypes = Idents(seurat.obj)
  ctypes.u = sort(as.character(unique(ctypes)))
  expr_l = array(NA, dim = c(length(genes), 
                             length(projids.u),
                             length(unique(ctypes))))
  dimnames(expr_l)[[1]] = genes
  dimnames(expr_l)[[2]] = projids.u
  dimnames(expr_l)[[3]] = ctypes.u
  ncell = rep(NA, length(ctypes.u))
  names(ncell) = ctypes.u
  for(ctype in ctypes.u){
    cat("processing", ctype, "...\n")
    ctype.obj = seurat.obj[, ctypes == ctype]
    DefaultAssay(ctype.obj) = "RNA"
    expr = ind_expr(counts = ctype.obj@assays$RNA@counts,
                    projids = ctype.obj@meta.data$Donor.ID,
                    projids.u = projids.u)
    cat("check gene order: ", all(rownames(expr) == genes), "\n")
    cat("check sample order: ", all(colnames(expr) == projids.u), "\n")
    expr_l[,, as.character(ctype)] = expr
    ncell[as.character(ctype)] = sum(seurat.obj$ctypes == ctype)
  }
  return(list(expr_l = expr_l,
              ncell = ncell))
}


#' select cell-type express genes
#' express genes: counts > min_counts in at least min_pct of individuals
#' @param ctype_ind matrix/data.frame; in shape of [genes, individuals]
#' @param min_count numeric; expressed genes = counts > min_count
#' @param min_pct numeric; 
ngenes_expr_ind = function(ctype_ind, min_count, min_pct){
  nind_expr = rowMeans(ctype_ind > min_count)
  is_expr = nind_expr > min_pct
  return(list(is_expr = is_expr, ngenes = sum(is_expr)))
}


#' number of express genes:
#' evaluated by individual level
#' @param counts_l list; list generated by @counts_ctype
#' @param dataset string; name of data set
#' @param min_counts
n_expr_genes = function(counts_l, dataset, min_pct = 0.3,
                        min_counts = seq(0, 500, by = 5)){
  expr_l = counts_l$expr_l
  ctypes = dimnames(expr_l)[[3]]
  expr_genes_ind = list()
  for(ctype in ctypes){
    ind_counts = expr_l[,, ctype]
    expr_genes_ind[[ctype]] = data.table(
      min_counts = min_counts,
      number_of_genes = sapply(min_counts, 
    function(min_count) ngenes_expr_ind(ind_counts, min_count, min_pct)$ngenes),
      data = dataset,
      celltype = ctype,
      ncell = counts_l$ncell[ctype])
  }
  expr_genes_ind = do.call(rbind, expr_genes_ind)
  return(expr_genes_ind)
}


# number of express genes
# evaluate by cell level:
#' @param obj seurat.obj
#' @param min_count numeric; 
#' @param min_pct_cell
#' @param min_pct_ind 
n_expr_genes_cell = function(obj, min_count, min_pct_cell, min_pct_ind){
  
}


#' read all .rds data from one dir
#' @param dir_path
#' @param names_by_col
read_seurat_dir = function(dir_path, names_by_col = "Donor.ID"){
  if(dir.exists(dir_path)){
    file_paths = list.files(dir_path, full.names = T)
    obj_l = lapply(file_paths, function(file_path){
      cat("processing", file_path, "\n")
      return(readRDS(file_path))
    })
    names(obj_l) = unlist(lapply(obj_l, function(obj) return(unique(as.character(unlist(obj[[names_by_col]]))))))
    return(obj_l)
  }else{
    stop("file don't exist\n")
  }
}

#' z-score of interested genes across subclusters
#' @param 
#' 
subc_zscore = function(seurat.obj, genes){
  counts = seurat.obj@counts
}

#' log push: write log to files
#' @param con string; 
#' @param log_file string; path to the log file
log_push = function(..., log_file = options()$log_file){
  char = paste(...)
  write(char, log_file, append = T)
}


#' is given genes in top pc genes?
#' @param pc_featurel matrix of pc feature loading; in shape of [gene, PCs]
#' @param gene_names vector; list of gene symbol
#' @param n_top numeric; number of top genes; default 10
#' top pc genes: abs(PC score) is top X in that PC
#' @param dt T/F; if T return a data.table; else return matrix; default F
is_in_top_pc_genes = function(pc_featurel, gene_names, n_top = 10, dt = F){
  top_genes_pcs = apply(pc_featurel, 2, function(pc_s){
    rownames(pc_featurel)[which(abs(pc_s) %in% head(sort(abs(pc_s), decreasing = T), n_top))]
  })
  dat = sapply(gene_names, function(gene) apply(top_genes_pcs, 2, function(genes) gene %in% genes))
  if(dt){
    dat = df_to_dt(as.data.frame(dat), rowcol = "PC")
    return(dat)
  }else{
    return(dat)
  }
}


#' save seurat data in 10X format
#' @param seurat.obj seurat object
#' @param dir_path string; path to store the data
seurat_to_10X = function(seurat.obj, dir_path){
  DefaultAssay(seurat.obj) = "RNA"
  cat("data save to", dir_path, "...\n")
  cat("saving counts data from RNA assay...\n")
  writeMM(seurat.obj@assays$RNA@counts, file = paste0(dir_path = "matrix.mtx"))
  cat("saving gene names (rownames) from RNA assay...\n")
  fwrite(data.table(gene_symbols = rownames(seurat.obj)), paste0(dir_path, "/features.tsv"))
  cat("saving @meta.data from RNA assay...\n")
  write.csv(seurat.obj@meta.data, paste0(dir_path, "/barcodes.tsv"))
  cat("make gz files...")
  com = paste0("gzip ",  dir_path, "/*")
  cat(com, "\n")
  system(com)
  cat("done..\n")
}


#' select protein coding genes
#' @seurat.obj seurat object
select_protein_genes = function(obj){
  gene_annot = fread("../data/ensembl_human_GRCh38.p13.txt")
  
  ## select protein coding genes:
  cat("select protein coding genes.\n")
  ### protein coding genes
  gene_annot = unique(gene_annot[, .(geneid = `Gene stable ID`,
                                     symbol = `HGNC symbol`, gene_type = `Gene type`)])
  gene_annot = data.table(symbol = rownames(obj))[
    gene_annot, on = .(symbol), gene_type := i.gene_type]
  protein_genes = gene_annot[gene_type == "protein_coding", symbol]
  obj = obj[protein_genes, ]
  cat("selected data has", nrow(obj), "genes...\n")
  
  return(obj)
}


#' format normalized counts data generated by counts_n.R
#' @param genes vector; a list of genes
#' @param counts_n array; a array of normalized counts generated by counts_n.R
#' @param brain_region_name; string; which brain region the data comes from
#' @param celltypes; vector; a list of celltype to choose
n_counts = function(genes, counts_n, brian_region_name,
                    celltypes = c("astrocytes", "endothelial", "microglia", 
                                  "neurons", "oligodendrocytes")){
  genes_n = lapply(genes, function(gene){
    gene_n = counts_n[gene, , celltypes]
    gene_n = as.data.frame(gene_n)
    gene_n[, "Donor.ID"] = rownames(gene_n)
    setDT(gene_n)
    gene_n[, brain_region := brian_region_name]
    gene_n[, gene := gene]
    return(gene_n)
  })
  return(do.call(rbind, genes_n))
}
